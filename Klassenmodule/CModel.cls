VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "CModel"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Option Explicit

Implements IModel

Dim CellWidth As Integer    'Characters per Cell in output file
Dim NumCommand As String
Dim NumSuffix As String
Dim convertDollar As Boolean
Dim booktabs As Boolean
Dim tableFloat As Boolean
Dim addNumCommand As Boolean
Dim addTabular As Boolean
Dim skipOne As Boolean
Dim NumMid As String
Dim Indent As Integer
Dim FullText As String
Dim sFileName As String
Dim RangeToUse As Range
Dim lastWasNum As Boolean

Private mpEvents As New IModelEvents

' IModel implementation

Public Property Get IModel_Events() As IModelEvents
    Set IModel_Events = mpEvents
End Property

Public Property Get IModel_Options() As x2lOptions
    If convertDollar Then IModel_Options = IModel_Options Or x2lConvertMathChars
    If booktabs Then IModel_Options = IModel_Options Or x2lBooktabs
    If tableFloat Then IModel_Options = IModel_Options Or x2lCreateTableEnvironment
    If addNumCommand Then IModel_Options = IModel_Options Or x2lAddNumCommand
    If addTabular Then IModel_Options = IModel_Options Or x2lCreateTabular
    If skipOne Then IModel_Options = IModel_Options Or x2lSkipOne
End Property
Public Property Let IModel_Options(ByVal Options As x2lOptions)
    Dim oldOptions As x2lOptions
    oldOptions = IModel_Options()
    
    convertDollar = (Options And x2lConvertMathChars) <> x2lNone
    booktabs = (Options And x2lBooktabs) <> x2lNone
    tableFloat = (Options And x2lCreateTableEnvironment) <> x2lNone
    addNumCommand = (Options And x2lAddNumCommand) <> x2lNone
    addTabular = (Options And x2lCreateTabular) <> x2lNone
    skipOne = (Options And x2lSkipOne) <> x2lNone
    
    If oldOptions <> IModel_Options() Then
        mpEvents.RaiseChanged
    End If
End Property

Public Property Get IModel_Indent() As Integer
    IModel_Indent = Indent
End Property
Public Property Let IModel_Indent(ByVal iIndent As Integer)
    If Indent = iIndent Then Exit Property
    Indent = iIndent
    mpEvents.RaiseChanged
End Property

Public Property Get IModel_CellWidth() As Integer
    IModel_CellWidth = CellWidth
End Property
Public Property Let IModel_CellWidth(ByVal iCellWidth As Integer)
    If CellWidth = iCellWidth Then Exit Property
    CellWidth = iCellWidth
    mpEvents.RaiseChanged
End Property

Public Property Get IModel_NumCommand() As String
    IModel_NumCommand = NumCommand
End Property
Public Property Let IModel_NumCommand(ByVal iNumCommand As String)
    If NumCommand = iNumCommand Then Exit Property
    NumCommand = iNumCommand
    mpEvents.RaiseChanged
End Property

Public Property Get IModel_NumSuffix() As String
    IModel_NumSuffix = NumSuffix
End Property
Public Property Let IModel_NumSuffix(ByVal iNumSuffix As String)
    If NumSuffix = iNumSuffix Then Exit Property
    NumSuffix = iNumSuffix
    mpEvents.RaiseChanged
End Property

Public Property Get IModel_NumMid() As String
    IModel_NumMid = NumMid
End Property
Public Property Let IModel_NumMid(ByVal iNumMid As String)
    If NumMid = iNumMid Then Exit Property
    NumMid = iNumMid
    mpEvents.RaiseChanged
End Property

Public Property Get IModel_FileName() As String
    IModel_FileName = sFileName
End Property
Public Property Let IModel_FileName(ByVal iFileName As String)
    Dim sBaseDir As String
    sBaseDir = WorksheetDir
    If UCase(iFileName) Like UCase(sBaseDir) & "\*" Then
        iFileName = Mid$(iFileName, Len(sBaseDir) + 2)
    End If
    sFileName = iFileName
End Property
Public Property Get IModel_AbsoluteFileName() As String
    If sFileName Like "?:\*" Or sFileName Like "\\*\*" Then
        IModel_AbsoluteFileName = sFileName
    Else
        IModel_AbsoluteFileName = Printf("%1\%2", WorksheetDir, sFileName)
    End If
End Property

Public Property Get IModel_RangeAddress() As String
    IModel_RangeAddress = RangeToAddress(RangeToUse)
End Property
Public Property Let IModel_RangeAddress(ByVal iRange As String)
    Set RangeToUse = AddressToRange(iRange)
    mpEvents.RaiseChanged
End Property

Public Function IModel_GetConversionResult() As String
    Dim r As Range, rc As Range, c As Range
    Dim FileName As String
    Dim i As Integer
    Dim j As Integer
    Dim pos As Integer
    
    FullText = ""
    If RangeToUse Is Nothing Then
        AddText "% Error: No range selected.", True
        GoTo leave
    End If
    AddText Space(Indent) + "% Table generated by Excel2LaTeX from sheet '" + RangeToUse.Worksheet.Name + "'", True
    
    If tableFloat Then
        AddText Space(Indent) + "\begin{table}[htbp]", True
        Indent = Indent + 2
        AddText Space(Indent) + "\centering", True
        AddText Space(Indent) + "\caption{Add caption}", True
        Indent = Indent + 2
    End If
    
    If addTabular Then
        AddText Space(Indent) + "\begin{tabular}{"
        AddText GetColumnsFormat(RangeToUse)
        AddText "}", True
    End If
      
    'Start checking top border
    Set r = RangeToUse.Rows(1)
    
    If booktabs Then
        AddText Space(Indent) + "\toprule", True
    Else
        AddText HorizontalBorder(r, Indent)
    End If
    
    'Table contents:
    For j = 1 To RangeToUse.Rows.Count ' for each row
        Set r = RangeToUse.Rows(j)
        Set rc = r.Cells
        If (j = 2) And booktabs Then
            AddText Space(Indent) + "\midrule", True
        End If
        AddText Space(Indent)
        Indent = Indent + 2
    
        For i = 1 To rc.Count  ' for each cell in row r
            Set c = rc.Item(i)
            i = i + AddCell(c, i = 1, i + c.MergeArea.Columns.Count > rc.Count) - 1
        Next i 'cells in row
        
        ' Struts and end of line
        AddText Printf("%1\\", GetStruts(r)), True
        Indent = Indent - 2
        
        ' Check for Border lines
        If Not booktabs Then
            AddText HorizontalBorder(r.Offset(RowOffset:=1), Indent)
        End If
    Next j 'row
    
theend:      'Tabellenende
    If booktabs Then
        AddText Space(Indent) + "\bottomrule", True
    End If
    
    If addTabular Then
        AddText Space(Indent) + "\end{tabular}%", True
    End If
    
    If tableFloat Then
        Indent = Indent - 2
        AddText Space(Indent) + "\label{tab:addlabel}%", True
        Indent = Indent - 2
        AddText Space(Indent) + "\end{table}%", True
    End If
    
leave:
    IModel_GetConversionResult = FullText
    
    ' Save to registry after successful conversion
    SaveToRegistry
End Function

Public Sub IModel_InitDefault()
    Indent = 0
    CellWidth = 5
    NumCommand = "\num{"
    NumSuffix = "}"
    NumMid = " \pm"
    IModel_Options = x2lBooktabs Or x2lConvertMathChars Or x2lCreateTableEnvironment Or x2lCreateTabular
    lastWasNum = False
    
    InitFromRegistry

    Set RangeToUse = GetDefaultRange
    sFileName = GetDefaultFileName
End Sub

Private Property Get IModel_Description() As String
    If RangeToUse Is Nothing Then
        IModel_Description = "(empty range)"
        Exit Property
    End If
    IModel_Description = Printf("%1: %2", Me.IModel_RangeAddress, Me.IModel_FileName)
End Property

Private Property Get IModel_Range() As Range
    Set IModel_Range = RangeToUse
End Property
Private Property Set IModel_Range(ByVal pRange As Range)
    Set RangeToUse = pRange.Areas(1)
    mpEvents.RaiseChanged
End Property

' Class implementation

Private Sub InitFromRegistry()
    On Error Resume Next
    StringToModel Me, VBA.GetSetting("Excel2LaTeX", "Main", "DefaultSettings")
End Sub

Private Sub SaveToRegistry()
    On Error Resume Next
    VBA.SaveSetting "Excel2LaTeX", "Main", "DefaultSettings", ModelToString(Me)
End Sub

Private Function WorksheetDir() As String
    If RangeToUse Is Nothing Then
        WorksheetDir = "."
        Exit Function
    End If
    
    WorksheetDir = RangeToUse.Worksheet.Parent.PATH
End Function

Private Function GetDefaultRange() As Range
    If Selection Is Nothing Then Exit Function
    If TypeName(Selection) <> "Range" Then Exit Function
    
    Set GetDefaultRange = Selection
End Function

Private Function GetDefaultFileName()
    Dim sName As String
    On Error Resume Next
    sName = ActiveSheet.Name
    sName = RangeToUse.Name.Name
    On Error GoTo 0
    GetDefaultFileName = Printf("%1.tex", sName)
End Function

Private Sub AddText(ByVal txt As String, Optional ByVal LineFeed = False)
    If LineFeed Then txt = txt + vbLf
    FullText = FullText + txt
End Sub

Private Function PadSpace(ByVal n As Long)
    PadSpace = Space(Application.WorksheetFunction.Max(0, n))
End Function

Private Function GetStruts(ByVal rRow As Range) As String
    Debug.Assert rRow.Rows.Count = 1
    
    ' No struts in booktabs mode
    If booktabs Then Exit Function
    
    Dim bHasTopBorder As Boolean
    Dim bHasBottomBorder As Boolean
    
    bHasTopBorder = HasHorizontalBorder(rRow)
    bHasBottomBorder = HasHorizontalBorder(rRow.Offset(RowOffset:=1))
    
    If bHasTopBorder Then
        If bHasBottomBorder Then
            GetStruts = "\bigstrut"
        Else
            GetStruts = "\bigstrut[t]"
        End If
    Else
        If bHasBottomBorder Then
            GetStruts = "\bigstrut[b]"
        End If
    End If
End Function

Private Function GetColumnsFormat(ByVal RangeToUse As Range, Optional ByVal bSkipFirst = False, Optional ByVal lStep As Long = 1) As String
    Dim rc As Range, c As Range, cn As Range
    
    Dim i As Long
    Dim stg As String
    
    Set rc = RangeToUse.Columns
    Set cn = rc.Item(1)
    
    If Not bSkipFirst Then
        stg = VerticalBorder(cn)
    End If
    
    For i = 1 To rc.Count Step lStep
        Set c = cn
        Set cn = Nothing
        On Error Resume Next
        Set cn = rc(i + lStep)
        On Error GoTo 0
        Select Case c.HorizontalAlignment
        Case xlLeft
            stg = stg + "l"
        Case xlCenter
            stg = stg + "c"
        Case Else
            stg = stg + "r" 'Default alignment is right
        End Select
        If Not (cn Is Nothing) Then
            stg = stg + VerticalBorder(cn)
        End If
    Next i
    GetColumnsFormat = stg
End Function

Private Function VerticalBorder(ByVal pRightRange As Range)
    ' No vertical borders for booktabs style
    If booktabs Then Exit Function
    
    'return nothing, | or ||
    Dim stg As String
    Select Case VerticalBorderStyle(pRightRange)
    Case xlDouble
        stg = "||"
    Case xlContinuous
        stg = "|"
    Case Else
        stg = ""
    End Select
    VerticalBorder = stg
End Function

Private Function VerticalBorderStyle(ByVal pRightRange As Range) As Variant
    VerticalBorderStyle = xlNone
    
    Dim pRightRow As Range
    Dim pLeftRow As Range
    For Each pRightRow In pRightRange.Rows
        VerticalBorderStyle = ResolveLine(VerticalBorderStyle, pRightRow.Borders(xlLeft).LineStyle)
        
        If pRightRow.Column > 1 Then
            Set pLeftRow = pRightRow.Resize(ColumnSize:=1).Offset(ColumnOffset:=-1)
            
            VerticalBorderStyle = ResolveLine(VerticalBorderStyle, pLeftRow.Borders(xlRight).LineStyle)
        End If
    Next
End Function

Private Function HasHorizontalBorder(ByVal rBelowRange As Range) As Boolean
    HasHorizontalBorder = (HorizontalBorder(rBelowRange, 0) <> "")
End Function

Private Function HorizontalBorder(ByVal rBelowRange As Range, ByVal spaces As Integer) As String
    Debug.Assert rBelowRange.Rows.Count = 1
    
    Dim rAboveRange As Range
    If rBelowRange.Row > 1 Then
        Set rAboveRange = rBelowRange.Offset(RowOffset:=-1)
    End If
    
    Dim sRangeDef As String
    Dim lLineOpenFrom As Long
    Dim bOpenLine As Boolean
    Dim borderStyle As Variant
    
    Dim rBelowColumn As Range
    Dim rAboveColumn As Range
    For Each rBelowColumn In rBelowRange.Columns
        If Not rAboveRange Is Nothing Then
            Set rAboveColumn = rAboveRange.Columns(rBelowColumn.Column - rBelowRange.Column + 1)
        End If
        
        If Not IsFirstRowOfMultiRowCell(rBelowColumn) Then
            bOpenLine = False
        Else
            borderStyle = ResolveHorizontalLine(rBelowColumn, rAboveColumn)
            bOpenLine = (borderStyle <> xlNone)
        End If
        
        AppendToRangeSet sRangeDef, lLineOpenFrom, bOpenLine, rBelowColumn.Column - rBelowRange.Column + 1
    Next
    
    AppendToRangeSet sRangeDef, lLineOpenFrom, False, rBelowRange.Columns.Count + 1
    
    ' Straight line? => revert to old behavior
    If sRangeDef = Printf("1-%1", rBelowRange.Columns.Count) Then
        'return nothing, \hline or \hline\hline
        borderStyle = ResolveHorizontalLine(rBelowRange, rAboveRange)
    
        Select Case borderStyle
        Case xlDouble
            HorizontalBorder = Space(spaces) + "\hline" + vbLf + Space(spaces) + "\hline" + vbLf
        Case xlContinuous
            HorizontalBorder = Space(spaces) + "\hline" + vbLf
        Case Else
            HorizontalBorder = ""
        End Select
    ElseIf sRangeDef = "" Then
        HorizontalBorder = ""
    Else
        HorizontalBorder = Printf("\cline{%1}", Replace(sRangeDef, ";", "}\cline{"))
    End If
End Function

Public Sub AppendToRangeSet(ByRef sRangeDef As String, ByRef lLineOpenFrom As Long, ByVal bOpenLine As Boolean, ByVal lCurrentPos As Long)
    If bOpenLine Then
        If lLineOpenFrom <= 0 Then
            lLineOpenFrom = lCurrentPos
            sRangeDef = Printf("%1%3%2", sRangeDef, lCurrentPos, IIf(sRangeDef = "", "", ";"))
        End If
    Else
        If lLineOpenFrom > 0 Then
            sRangeDef = Printf("%1-%2", sRangeDef, lCurrentPos - 1)
            lLineOpenFrom = 0
        End If
    End If
End Sub

Private Function ResolveHorizontalLine(ByVal rBelowRange As Range, ByVal rAboveRange As Range)
    ResolveHorizontalLine = rBelowRange.Borders(xlTop).LineStyle
    If rAboveRange Is Nothing Then Exit Function
    ResolveHorizontalLine = ResolveLine(ResolveHorizontalLine, rAboveRange.Borders(xlBottom).LineStyle)
End Function

Private Function ResolveLine(ByVal line1, ByVal line2)
    ResolveLine = xlNone
    If line1 = xlContinuous Or line2 = xlContinuous Then ResolveLine = xlContinuous
    If line1 = xlDouble Or line2 = xlDouble Then ResolveLine = xlDouble
End Function

Private Function AddCell(ByVal rCell As Range, ByVal bFirstCell As Boolean, ByVal bLastCell As Boolean) As Long
    Dim txt As String
    Dim nColumns As Long
    Dim nRows As Long
    
    txt = FormatCell(rCell)
    
    Dim bRequiresDifferentVlineFormat As Boolean
    bRequiresDifferentVlineFormat = RequiresDifferentVlineFormat(rCell)
    
    'Check for multicolumns
    If rCell.MergeCells Or bRequiresDifferentVlineFormat Then   'multicolumn cell
        With rCell.MergeArea
            nColumns = .Columns.Count
            nRows = .Rows.Count
        End With
        
        If nRows > 1 Then
            ' Add contents only for first row of a multi-row cell
            If IsFirstRowOfMultiRowCell(rCell) Then
                txt = Printf("\multirow{%1}[%3]{*}{%2}", nRows, txt, GetMultiRowStruts(rCell))
            Else
                txt = ""
            End If
        End If
        If (nColumns > 1) Or bRequiresDifferentVlineFormat Then
            txt = Printf("\multicolumn{%1}{%2}{%3}", _
                nColumns, _
                GetColumnsFormat(rCell.MergeArea, Not bFirstCell, rCell.MergeArea.Columns.Count), _
                txt)
        End If
    Else 'single cell
        nColumns = 1
        nRows = 1
    End If
    
    AddText txt
    If Not bLastCell Then
        If (skipOne And lastWasNum) Then
            AddText NumMid
        Else
            AddText " &"
        End If
        If CellWidth > 0 Then
            AddText PadSpace(nColumns * (3 + CellWidth) - 3 - Len(txt))
        End If
    End If
    If CellWidth > 0 Then
        If (Not (skipOne And lastWasNum)) Then _
            AddText " "
    Else
        AddText vbLf & Space(Indent)
    End If
    
    AddCell = nColumns
End Function

Private Function FormatCell(ByVal rCell As Range) As String
    FormatCell = rCell.Text
    
    FormatCell = ConvertSpecialChars(FormatCell)
    FormatCell = createNumCommand(FormatCell)
    FormatCell = FormatCellFont(FormatCell, rCell)
    FormatCell = FormatCellOrientation(FormatCell, rCell)
End Function

Private Function createNumCommand(ByVal sText As String) As String
    createNumCommand = sText
    
    If (IsNumeric(sText) And addNumCommand And (NumCommand <> "" Or NumSuffix <> "")) Then
        If skipOne Then
            If lastWasNum Then
                createNumCommand = sText & NumSuffix
                lastWasNum = False
            Else
                createNumCommand = NumCommand & sText
                lastWasNum = True
            End If
        Else
            createNumCommand = NumCommand & sText & NumSuffix
        End If
    Else
        lastWasNum = False
    End If
End Function

Private Function ConvertSpecialChars(ByVal sText As String) As String
    ConvertSpecialChars = sText
    
    'Check for special characters % and $
    If convertDollar Then
        ConvertSpecialChars = Replace(ConvertSpecialChars, "\", "\textbackslash{}")
        ConvertSpecialChars = Replace(ConvertSpecialChars, "$", "\$")
        ConvertSpecialChars = Replace(ConvertSpecialChars, "_", "\_")
        ConvertSpecialChars = Replace(ConvertSpecialChars, "^", "\^")
    End If
    ConvertSpecialChars = Replace(ConvertSpecialChars, "%", "\%")
    ConvertSpecialChars = Replace(ConvertSpecialChars, "&", "\&")
    ConvertSpecialChars = Replace(ConvertSpecialChars, "#", "\#")
End Function

Private Function FormatCellFont(ByVal sText As String, ByVal rCell As Range) As String
    Dim pFont As Font
    Set pFont = rCell.Font
    
    FormatCellFont = sText
    
    'Check for Font Styles
    If pFont.Bold Then FormatCellFont = Printf("\textbf{%1}", FormatCellFont)
    If pFont.Italic Then FormatCellFont = Printf("\textit{%1}", FormatCellFont)
    
    'Typeset math in bold if required
    If Not pFont.Bold Then
    ElseIf convertDollar Then
    ElseIf InStr(1, FormatCellFont, "$") > 0 Then
        FormatCellFont = Printf("\boldmath{}%1\unboldmath{}", FormatCellFont)
    End If
End Function

Private Function FormatCellOrientation(ByVal sText As String, ByVal rCell As Range) As String
    ' Requires "rotating" package
    FormatCellOrientation = sText
    
    ' Check for orientation
    Select Case rCell.Orientation
    Case xlHorizontal
        ' Do nothing
        
    Case xlUpward
        FormatCellOrientation = Printf("\begin{sideways}%1\end{sideways}", FormatCellOrientation)
        
    Case xlDownward
        FormatCellOrientation = Printf("\begin{turn}{-90}%1\end{turn}", FormatCellOrientation)
        
    Case Else
        FormatCellOrientation = Printf("\begin{turn}{%2}%1\end{turn}", FormatCellOrientation, rCell.Orientation)
    
    End Select
End Function

Private Function RequiresDifferentVlineFormat(ByVal rCell As Range) As Boolean
    Dim sColumnFormat As String
    Dim sCellFormat As String
    
    Dim lRelativeColumn As Long
    lRelativeColumn = GetRelativeColumn(rCell)
    
    Dim rColumn As Range
    Set rColumn = RangeToUse.Columns(lRelativeColumn)
    
    sColumnFormat = GetColumnsFormat(rColumn, lRelativeColumn > 1, rCell.MergeArea.Columns.Count)
    sCellFormat = GetColumnsFormat(rCell, lRelativeColumn > 1, rCell.MergeArea.Columns.Count)
    
    RequiresDifferentVlineFormat = (sColumnFormat <> sCellFormat)
End Function

Private Function GetRelativeColumn(ByVal rCell As Range) As Long
    GetRelativeColumn = rCell.Column - RangeToUse.Column + 1
End Function

Private Function GetRelativeRow(ByVal rCell As Range) As Long
    GetRelativeRow = rCell.Row - RangeToUse.Row + 1
End Function

Function IsFirstRowOfMultiRowCell(ByVal rCell As Range) As Boolean
    IsFirstRowOfMultiRowCell = (rCell.Row = rCell.MergeArea.Row)
End Function

Function GetMultiRowStruts(ByVal rCell As Range) As Long
    Dim lStartRow As Long
    Dim lEndRow As Long
    Dim lRow As Long
    Dim bBorder As Boolean
    
    lStartRow = GetRelativeRow(rCell)
    lEndRow = lStartRow + rCell.MergeArea.Rows.Count
    
    For lRow = lStartRow To lEndRow
        bBorder = HasHorizontalBorder(RangeToUse.Rows(lRow))
        
        ' First and last horizontal lines account for one strut,
        ' the others account for two struts each:
        If bBorder Then
            GetMultiRowStruts = GetMultiRowStruts + 1
            If (lRow > lStartRow) And (lRow < lEndRow) Then
                GetMultiRowStruts = GetMultiRowStruts + 1
            End If
        End If
    Next
End Function
